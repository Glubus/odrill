use crate::project::TemplateProject;
use anyhow::{Context, Result, anyhow};
use colored::Colorize;
use pkg::{ModPackage, OdrillProject};
use std::fs;
use std::path::Path;
use walkdir::WalkDir;

pub fn pack(path: impl AsRef<Path>) -> Result<Vec<u8>> {
    let root = path.as_ref();

    println!("ðŸ” Validating template structure...");

    // 1. Load Template Project (Meta)
    let tmpl_project = TemplateProject::load(root)?;

    // 2. Verify Inner Odrill Project (Integrity)
    if !root.join("odrill.toml").exists() {
        return Err(anyhow!(
            "Missing 'odrill.toml'. A template must be a valid Odrill project."
        ));
    }

    // Try to load it to ensure TOML is valid (even with placeholders)
    println!("  - Checking '{}'...", "odrill.toml".cyan());
    let odrill_project = OdrillProject::load(root)
        .context("Invalid 'odrill.toml'. Ensure format is correct even with placeholders.")?;

    // 3. Security Scan
    println!("  - Scanning for suspicious code...");
    let scanner = container::security::scan::Scanner::new();
    let mut vulnerabilities = Vec::new();

    for entry in WalkDir::new(root) {
        let entry = match entry {
            Ok(e) => e,
            Err(_) => continue,
        };

        if entry.path().is_dir() {
            continue;
        }
        let path = entry.path();

        if let Some(ext) = path.extension().and_then(|s| s.to_str()) {
            if ext == "lua" {
                let content = fs::read_to_string(path).unwrap_or_default();
                let issues = scanner.scan(&content);
                if !issues.is_empty() {
                    vulnerabilities.push((path.display().to_string(), issues));
                }
            }
        }
    }

    if !vulnerabilities.is_empty() {
        println!("{}", "âŒ Security checks failed:".red().bold());
        for (file, issues) in vulnerabilities {
            println!("  In {}: {:?}", file.yellow(), issues);
        }
        return Err(anyhow!("Template contains suspicious code patterns."));
    }

    // 4. Verify Compilation (Compilability)
    println!("  - Verifying compilation pass...");
    let mut compiler = compiler::Compiler::new(odrill_project.clone());
    // We try to compile. If it fails (e.g. invalid hook definitions), we abort.
    match compiler.compile_all() {
        Ok(_) => println!("    {} Compilation successful.", "âœ“".green()),
        Err(e) => {
            return Err(anyhow!(
                "Template failed to compile: {}. Fix errors before publishing.",
                e
            ));
        }
    }

    // Clean up dist/ if generated by verify
    let _ = fs::remove_dir_all(root.join("dist"));

    // 5. Pack
    println!("ðŸ“¦ Packing template files...");
    let mut pkg = ModPackage::new(
        &tmpl_project.manifest.template.name,
        &tmpl_project.manifest.template.version,
    );

    for entry in WalkDir::new(root) {
        let entry = match entry {
            Ok(e) => e,
            Err(_) => continue,
        };
        let path = entry.path();

        if path.is_dir() {
            continue;
        }

        // Ignore logic
        if path.to_string_lossy().contains("target")
            || path.to_string_lossy().contains(".git")
            || path.to_string_lossy().contains("dist")
            || path.ends_with("template.toml")
        {
            continue;
        }

        let relative = path
            .strip_prefix(root)?
            .to_string_lossy()
            .replace("\\", "/");
        let content = fs::read(path)?;

        pkg.add_file(relative, content);
    }

    container::encode(&pkg)
}
